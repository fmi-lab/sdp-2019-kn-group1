# Приоритетна опашка

Приоритетната опашка е структура от данни, подобна на стека и опашката с това, че
имаме достъп само до един елемент. За разлика от тях обаче, този елемент не е първият или последният добавен,
а е елементът с най-голям (или най-малък, в зависимост от една настройка) приоритет.

Пример: Приоритетна опашка MaxQueue, връщаща най-големия елемент:

<pre>
MaxQueue mq;
mq.push(11);
mq.push(5);
mq.push(12);
mq.push(2019);

// Този цикъл извежда: 2019 12 11 5
while(!mq.empty()) {
    cout << mq.top() << " ";
    mq.pop();
}
</pre>

Една стандартна реализация на приоритетна опашка е двоично дърво, в което всеки елемент е по-голям от
наследниците си, например:

<pre>
           100
         /     \  
       15       30  
      /  \     /  \
     5    4   6    10
</pre>

Напишете клас MaxQueue, представящ приоритетна опашка с Node-ове като дърво.
Трябва да има методи push, pop и top, като:

- Можем да премахнем само върха
- Премахването става чрез замяната му с по-малкото от двете му деца
- Добавянето става по подобие на вмъкването в обикновено дърво, само че слизаме надолу, докато не намерим
място, в което елементът е по-голям от децата си

