# Двоично дърво - част 2

### Задача 1.
Напишете метод height() за BinTree, връщащ височината на дървото, т.е. броя на нивата в него.
Приемете, че празното дърво има височина 0. Примерното дърво с височина 4:

<pre>
         2
       /   \
      3    100
     /    /   \ 
    4   200   300
          \
           18
</pre>

### Задача 2.
Напишете метод remove_at(const char* path), премахващ елемента на определена позиция от дървото, като:
- при премахване на листо, на негово място указателят да става nullptr
- при премахване на връх с едно дете, върхът да се замести с детето. Ако от примерното дърво махнем 3, трябва
да се получи:

<pre>
         2
       /   \
      4    100
          /   \ 
        200   300
          \
           18
</pre>

- при премахване на връх с две деца, върхът да се замести с корена на по-високото си поддърво, т.е. ако махнем
100, да се получи:

<pre>
         2
       /   \
      4    200
          /   \ 
        18    300
</pre>

Тук е важно преместеното 200 замени с 18, което пък да се замени с някое от неговите деца, ако има такива.

### Задача 3.
Напишете метод remove_element(int element), премахващ всички срещания на елемент в дървото, по същите правила
като в remove_at().

### Задача 4.
Напишете метод print_with_stack(), който принтира елементите на дървото, без да използва рекурсия. Както
подсказва името, ще се използва стек - в случая стек от поддървета (Node*), чакащи да им дойде редът. След
това напишете методи, аналогични на get_size() и height(), отново без рекурсия, а със стек.

### Задача 5.
Напишете итератор за BinTree. Тъй като при употребата на итератор се налага постъпково обхождане елемент по
елемент, и тук няма да стане с рекурсия. Ще ви трябва стек от поддървета (Node*).