# Двоично дърво

Напишете клас BinTree, представляващ двоично дърво. Може да използвате Node-ове като тези за свързания списък,
но с два указателя:

    struct Node {
        int data;       // или шаблонен тип
        Node* left;
        Node* right;
    }

Пример за дърво:

         2
       /   \
      3    100
     /    /   \ 
    4   200   300

Напишете следните методи (ако искате, работете със шаблонен клас):
- конструктор по подразбиране
- метод add_left(int element), добавящ елемент "възможно най-вляво", в примера - като ляво дете на 4
- метод add_right(int element), добавящ елемент "възможно най-вдясно", в примера - като дясно дете на 300
- метод get_size(), връщащ броя на елементите на дървото
- метод print(), принтиращ елементите на дървото в реда корен-ляво-дясно, в премера - 2 3 4 100 200 300.
Бонус: направете метода да принтира всеки елемент на отделен ред, показвайки йерархията:
    
    2
       3
          4
       100
          200
          300

<span></span>

- метод add(int element, const char* path) за добавяне на елемент на произволна позиция. Примете, че указателят
path сочи към символен низ, записан само с буквите L и R, който означава позиция в дървото. Позиции на елементите
в примерното дърво:

         2 ""
       /        \
      3 "L"      100 "R"
     /          /       \ 
    4 "LL"   200 "RL"    300 "RR"

В този метод path ще е позицията на новия елемент. Ако е "RLR", новият елемент трябва да се добави като дясно
дете на 200. Ако искате, използвайте string вместо char*.
Но ако пишете метода с рекурсия, е по-удобно да е char* :)

- метод reverse(), който "обръща" дървото:

         2                   2
       /   \               /   \
      3    100    --->    100    3
     /    /   \          /   \    \
    4   200   300      300   200   4

<span></span>

- private метод copy_of(Node* original), връщащ указател към копие на дървото с корен, сочен от original
- конструктор за копиране
- оператор =
- деструктор

Почти всечки методи (с изключение на add) изискват рекурсия за написването си, т.е. не могат да се напишат с
обикновен цикъл (могат да станат с използване на стек, но това ще го упражним по-натам). Това ще изисква,
по подобие на рекурсивния свързан списък, да имаме public и private версия на всеки метод и private версията
да приема допълнителен аргумент - указател към корен на поддърво. Не забравяйте да подавате указателите като *&,
където е необходимо.